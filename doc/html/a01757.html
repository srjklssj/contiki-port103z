<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Contiki 2.5: Flash</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash</div>  </div>
</div>
<div class="contents">

<p>Definition and description of public flash manipulation routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0cd5188b52772a3fa41c54475539188a"></a><!-- doxytag: member="flash::MFB_MASS_ERASE" ref="ga0cd5188b52772a3fa41c54475539188a" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01757.html#ga0cd5188b52772a3fa41c54475539188a">MFB_MASS_ERASE</a>&#160;&#160;&#160;0x01</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign numerical value to the type of erasure requested. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01759.html#ga7670a4e8a07d9ebb00411948b0bbf86d">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01757.html#ga04dc9eef74066ec15dcfbd603aaf4a52">halFlashEraseIsActive</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the calling code if a Flash Erase operation is active.  <a href="#ga04dc9eef74066ec15dcfbd603aaf4a52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01757.html#ga4444bbd2d2343a108894d5e0412c7e5c">halInternalFlashErase</a> (int8u eraseType, int32u address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a section of flash back to all 0xFFFF.  <a href="#ga4444bbd2d2343a108894d5e0412c7e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01757.html#ga5eae5ae946c993e4f710e0e9b17f18a7">halInternalFlashWrite</a> (int32u address, int16u *data, int32u length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a block of words to flash.  <a href="#ga5eae5ae946c993e4f710e0e9b17f18a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01757.html#ga6f413da8a04e1c9ddd3b429268347506">halInternalCibOptionByteWrite</a> (int8u byte, int8u data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an option byte to the customer information block.  <a href="#ga6f413da8a04e1c9ddd3b429268347506"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Definition and description of public flash manipulation routines. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>During an erase or a write the flash is not available, which means code will not be executable from flash. These routines still execute from flash, though, since the bus architecture can support doing so. <b>Additonally, this also means all interrupts will be disabled.</b></dd></dl>
<p><b>Hardware documentation indicates 40us for a write and 21ms for an erase.</b></p>
<p>See flash.h for source code. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga04dc9eef74066ec15dcfbd603aaf4a52"></a><!-- doxytag: member="flash.h::halFlashEraseIsActive" ref="ga04dc9eef74066ec15dcfbd603aaf4a52" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01759.html#ga7670a4e8a07d9ebb00411948b0bbf86d">boolean</a> halFlashEraseIsActive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the calling code if a Flash Erase operation is active. </p>
<p>This state is import to know because Flash Erasing is ATOMIC for 21ms and could disrupt interrupt latency. But if an ISR can know that it wasn't serviced immediately due to Flash Erasing, then the ISR has the opportunity to correct in whatever manner it needs to.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean flag: TRUE if Flash Erase is active, FALSE otherwise. </dd></dl>

<p>Definition at line <a class="el" href="a00670_source.html#l00041">41</a> of file <a class="el" href="a00670_source.html">flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f413da8a04e1c9ddd3b429268347506"></a><!-- doxytag: member="flash.h::halInternalCibOptionByteWrite" ref="ga6f413da8a04e1c9ddd3b429268347506" args="(int8u byte, int8u data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StStatus halInternalCibOptionByteWrite </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes an option byte to the customer information block. </p>
<p>Only two writes can be performed to the same address between erasures and this is enforced by the flash interface controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">byte</td><td>The option byte number, 0 though 7, to be programmed.</td></tr>
    <tr><td class="paramname">data</td><td>The 8 bit value to be programmed into the option byte. The hardware is responsible for calculating the compliment and programming the full 16bit option byte space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An ::StStatus value indicating the success or failure of the command:<ul>
<li>ST_ERR_FLASH_PROG_FAIL if the byte chosen is greater than 7, write protection is enabled, or the byte is being written to more than twice between erasures.</li>
<li>ST_ERR_FLASH_VERIFY_FAILED if write verification failed</li>
<li>ST_SUCCESS if writing completed and verified properly </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a00670_source.html#l00355">355</a> of file <a class="el" href="a00670_source.html">flash.c</a>.</p>

<p>References <a class="el" href="a00670_source.html#l00294">halInternalFlashWrite()</a>, and <a class="el" href="a01041_source.html#l00264">HIGH_LOW_TO_INT</a>.</p>

</div>
</div>
<a class="anchor" id="ga4444bbd2d2343a108894d5e0412c7e5c"></a><!-- doxytag: member="flash.h::halInternalFlashErase" ref="ga4444bbd2d2343a108894d5e0412c7e5c" args="(int8u eraseType, int32u address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StStatus halInternalFlashErase </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>eraseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases a section of flash back to all 0xFFFF. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eraseType</td><td>Choose one of the three types of erasures to perform.<ul>
<li>MFB_MASS_ERASE (0x01) Erase the entire main flash block.</li>
<li>MFB_PAGE_ERASE (0x02) Erase one hardware page in the main flash block chosen by the <code>address</code> parameter.</li>
<li>CIB_ERASE (0x03) Erase the entire customer information block.</li>
</ul>
</td></tr>
    <tr><td class="paramname">address</td><td>This parameter is only effectual when a MFB_PAGE_ERASE is being performed. The hardware page encapsulating the address given in this parameter will be erased. A hardware page size depends on the chip</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An ::StStatus value indicating the success or failure of the command:<ul>
<li>ST_ERR_FATAL if the <code>eraseType</code> is not valid</li>
<li>ST_ERR_FLASH_ERASE_FAIL if erasing failed due to write protection</li>
<li>ST_ERR_FLASH_VERIFY_FAILED if erase verification failed</li>
<li>ST_SUCCESS if erasure completed and verified properly </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a00670_source.html#l00231">231</a> of file <a class="el" href="a00670_source.html">flash.c</a>.</p>

<p>References <a class="el" href="a01016_source.html#l00452">ATOMIC</a>, <a class="el" href="a01041_source.html#l00175">FALSE</a>, and <a class="el" href="a01041_source.html#l00170">TRUE</a>.</p>

</div>
</div>
<a class="anchor" id="ga5eae5ae946c993e4f710e0e9b17f18a7"></a><!-- doxytag: member="flash.h::halInternalFlashWrite" ref="ga5eae5ae946c993e4f710e0e9b17f18a7" args="(int32u address, int16u *data, int32u length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StStatus halInternalFlashWrite </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a block of words to flash. </p>
<p>A page is erased to 0xFFFF at every address. Only two writes can be performed to the same address between erasures and this is enforced by the flash interface controller. If the value already in the address being written to is 0xFFFF, any value can be written. If the value is not 0xFFFF and not 0x0000, only 0x0000 can be written. If the value is 0x0000, nothing can be written.</p>
<p><b>NOTE:</b> This function can NOT write the option bytes and will throw an error if that is attempted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The starting address of where the programming will occur. This parameter MUST be half-word aligned since all programming operations are half-words. Also, the address parameter is NOT a pointer. This routines will cast the address to a pointer for the actual hardware access.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to a buffer containing the 16bit (half-words) to be written.</td></tr>
    <tr><td class="paramname">length</td><td>The number of 16bit (half-words) contained in the data buffer to be written to flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An ::StStatus value indicating the success or failure of the command:<ul>
<li>ST_ERR_FLASH_PROG_FAIL if the address is not half-word aligned, the address is inside the option bytes, write protection is enabled, or the address is being written to more than twice between erasures.</li>
<li>ST_ERR_FLASH_VERIFY_FAILED if write verification failed</li>
<li>ST_SUCCESS if writing completed and verified properly </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a00670_source.html#l00294">294</a> of file <a class="el" href="a00670_source.html">flash.c</a>.</p>

<p>References <a class="el" href="a01016_source.html#l00452">ATOMIC</a>.</p>

<p>Referenced by <a class="el" href="a00670_source.html#l00355">halInternalCibOptionByteWrite()</a>, and <a class="el" href="a01026_source.html#l00077">halInternalSetMfgTokenData()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 20:13:20 for Contiki 2.5 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
