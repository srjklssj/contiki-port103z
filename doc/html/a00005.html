<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Contiki 2.5: example-packet-drv.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">example-packet-drv.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * This is an example of how to write a network device driver (&quot;packet</span>
<span class="comment"> * driver&quot;) for Contiki. A packet driver is a regular Contiki process</span>
<span class="comment"> * that does two things:</span>
<span class="comment"> * # Checks for incoming packets and delivers those to the TCP/IP stack</span>
<span class="comment"> * # Provides an output function that transmits packets</span>
<span class="comment"> *</span>
<span class="comment"> * The output function is registered with the Contiki TCP/IP stack,</span>
<span class="comment"> * whereas incoming packets must be checked inside a Contiki process.</span>
<span class="comment"> * We use the same process for checking for incoming packets and for</span>
<span class="comment"> * registering the output function.</span>
<span class="comment"> */</span>

<span class="comment">/*</span>
<span class="comment"> * We include the &quot;contiki-net.h&quot; file to get all the network functions.</span>
<span class="comment"> */</span>
<span class="preprocessor">#include &quot;contiki-net.h&quot;</span>

<span class="comment">/*---------------------------------------------------------------------------*/</span>
<span class="comment">/*</span>
<span class="comment"> * We declare the process that we use to register with the TCP/IP stack,</span>
<span class="comment"> * and to check for incoming packets.</span>
<span class="comment"> */</span>
<a name="a0"></a><a class="code" href="a01684.html#ga27e9b6fc13f0438e37a198f69b38b4cf" title="Declare a process.">PROCESS</a>(example_packet_driver_process, <span class="stringliteral">&quot;Example packet driver process&quot;</span>);
<span class="comment">/*---------------------------------------------------------------------------*/</span>
<span class="comment">/*</span>
<span class="comment"> * Next, we define the function that transmits packets. This function</span>
<span class="comment"> * is called from the TCP/IP stack when a packet is to be transmitted.</span>
<span class="comment"> * The packet is located in the uip_buf[] buffer, and the length of the</span>
<span class="comment"> * packet is in the uip_len variable.</span>
<span class="comment"> */</span>
u8_t
example_packet_driver_output(<span class="keywordtype">void</span>)
{
  let_the_hardware_send_the_packet(uip_buf, <a name="a1"></a><a class="code" href="a01741.html#ga12a33f0c09711167bdf3dd7d7cf8c5a1" title="The length of the packet in the uip_buf buffer.">uip_len</a>);

  <span class="comment">/*</span>
<span class="comment">   * A network device driver returns always zero.</span>
<span class="comment">   */</span>
  <span class="keywordflow">return</span> 0;
}
<span class="comment">/*---------------------------------------------------------------------------*/</span>
<span class="comment">/*</span>
<span class="comment"> * This is the poll handler function in the process below. This poll</span>
<span class="comment"> * handler function checks for incoming packets and delivers them to</span>
<span class="comment"> * the TCP/IP stack.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">void</span>
pollhandler(<span class="keywordtype">void</span>)
{
  <span class="comment">/*</span>
<span class="comment">   * We assume that we have some hardware device that notifies us when</span>
<span class="comment">   * a new packet has arrived. We also assume that we have a function</span>
<span class="comment">   * that pulls out the new packet (here called</span>
<span class="comment">   * check_and_copy_packet()) and puts it in the uip_buf[] buffer. The</span>
<span class="comment">   * function returns the length of the incoming packet, and we store</span>
<span class="comment">   * it in the global uip_len variable. If the packet is longer than</span>
<span class="comment">   * zero bytes, we hand it over to the TCP/IP stack.</span>
<span class="comment">   */</span>
  <a class="code" href="a01741.html#ga12a33f0c09711167bdf3dd7d7cf8c5a1" title="The length of the packet in the uip_buf buffer.">uip_len</a> = check_and_copy_packet();

  <span class="comment">/*</span>
<span class="comment">   * The function tcpip_input() delivers the packet in the uip_buf[]</span>
<span class="comment">   * buffer to the TCP/IP stack.</span>
<span class="comment">   */</span>
  <span class="keywordflow">if</span>(<a class="code" href="a01741.html#ga12a33f0c09711167bdf3dd7d7cf8c5a1" title="The length of the packet in the uip_buf buffer.">uip_len</a> &gt; 0) {
    <a name="a2"></a><a class="code" href="a01626.html#ga0d5e21d13844dbebd703fb8ed6b058d0" title="Deliver an incoming packet to the TCP/IP stack.">tcpip_input</a>();
  }

  <span class="comment">/*</span>
<span class="comment">   * Now we&#39;ll make sure that the poll handler is executed repeatedly.</span>
<span class="comment">   * We do this by calling process_poll() with this process as its</span>
<span class="comment">   * argument.</span>
<span class="comment">   *</span>
<span class="comment">   * In many cases, the hardware will cause an interrupt to be executed</span>
<span class="comment">   * when a new packet arrives. For such hardware devices, the interrupt</span>
<span class="comment">   * handler calls process_poll() (which is safe to use in an interrupt</span>
<span class="comment">   * context) instead.</span>
<span class="comment">   */</span>
  <a name="a3"></a><a class="code" href="a01684.html#ga496ba132ce7a2ec12a8313dc05ab0142" title="Request a process to be polled.">process_poll</a>(&amp;example_packet_driver_process);
}
<span class="comment">/*---------------------------------------------------------------------------*/</span>
<span class="comment">/*</span>
<span class="comment"> * Finally, we define the process that does the work. </span>
<span class="comment"> */</span>
<a name="a4"></a><a class="code" href="a01684.html#gaa4cff8e4f3abc50c74619a90ae347200" title="Define the body of a process.">PROCESS_THREAD</a>(example_packet_driver_process, ev, data)
{
  <span class="comment">/*</span>
<span class="comment">   * This process has a poll handler, so we declare it here. Note that</span>
<span class="comment">   * the PROCESS_POLLHANDLER() macro must come before the PROCESS_BEGIN()</span>
<span class="comment">   * macro.</span>
<span class="comment">   */</span>
  <a name="a5"></a><a class="code" href="a01684.html#ga4159c99c908ca521cf8b9fdda4b7f64c" title="Specify an action when a process is polled.">PROCESS_POLLHANDLER</a>(pollhandler());

  <span class="comment">/*</span>
<span class="comment">   * This process has an exit handler, so we declare it here. Note that</span>
<span class="comment">   * the PROCESS_EXITHANDLER() macro must come before the PROCESS_BEGIN()</span>
<span class="comment">   * macro.</span>
<span class="comment">   */</span>
  <a name="a6"></a><a class="code" href="a01684.html#ga3dee46e19ad8848b86d9d06321b75c0e" title="Specify an action when a process exits.">PROCESS_EXITHANDLER</a>(exithandler());

  <span class="comment">/*</span>
<span class="comment">   * The process begins here.</span>
<span class="comment">   */</span>
  <a name="a7"></a><a class="code" href="a01684.html#ga8efc62947f2ca2c870f52896e0dc1a81" title="Define the beginning of a process.">PROCESS_BEGIN</a>();

  <span class="comment">/*</span>
<span class="comment">   * We start with initializing the hardware.</span>
<span class="comment">   */</span>
  initialize_the_hardware();

  <span class="comment">/*</span>
<span class="comment">   * Register the driver. This will cause any previously registered driver</span>
<span class="comment">   * to be ignored by the TCP/IP stack.</span>
<span class="comment">   */</span>
  tcpip_set_outputfunc(example_packet_driver_output);

  <span class="comment">/*</span>
<span class="comment">   * Now we&#39;ll make sure that the poll handler is executed initially. We do</span>
<span class="comment">   * this by calling process_poll() with this process as its argument.</span>
<span class="comment">   */</span>
  <a class="code" href="a01684.html#ga496ba132ce7a2ec12a8313dc05ab0142" title="Request a process to be polled.">process_poll</a>(&amp;example_packet_driver_process);

  <span class="comment">/*</span>
<span class="comment">   * And we wait for the process to exit.</span>
<span class="comment">   */</span>
  <a name="a8"></a><a class="code" href="a01684.html#ga996168a0f904c0e28e3f6ed18dddd129" title="Wait for an event to be posted to the process, with an extra condition.">PROCESS_WAIT_EVENT_UNTIL</a>(ev == PROCESS_EVENT_EXIT);

  <span class="comment">/*</span>
<span class="comment">   * Now we shutdown the hardware.</span>
<span class="comment">   */</span>
  shutdown_the_hardware();

  <span class="comment">/*</span>
<span class="comment">   * Here ends the process.</span>
<span class="comment">   */</span>
  <a name="a9"></a><a class="code" href="a01684.html#ga9c2681a0070eba8a7c9fdf4dbb6db05e" title="Define the end of a process.">PROCESS_END</a>();
}
<span class="comment">/*---------------------------------------------------------------------------*/</span>
</pre></div> </div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 20:12:57 for Contiki 2.5 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
