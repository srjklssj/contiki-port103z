<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Contiki 2.5: USB Mass Storage Task</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">USB Mass Storage Task</div>  </div>
<div class="ingroups"><a class="el" href="a01734.html">RZRAVEN USB Stick (Jackdaw)</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84a55b954a9d270664ddcdf4c3780ff3"></a><!-- doxytag: member="usbstorage::ENTRY_SIZE" ref="ga84a55b954a9d270664ddcdf4c3780ff3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga84a55b954a9d270664ddcdf4c3780ff3">ENTRY_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">FAT specification. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga623d8b583417db8483269264d5af1992"></a><!-- doxytag: member="usbstorage::LUN_0_EN" ref="ga623d8b583417db8483269264d5af1992" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga623d8b583417db8483269264d5af1992">LUN_0_EN</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed the maximum of static lun (don't add the lun of Mass Storage in mode USB Host) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga3d068dfd6cc43279a8f57456a9898754">ID_STREAM_ERR</a>&#160;&#160;&#160;0xFF</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define control status. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga77ad6433358d065ff854213e9373d7f5">avrf_mem_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the hw/sw ressources required to drive the AVR Flash.  <a href="#ga77ad6433358d065ff854213e9373d7f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga6e798ae4398574d515c802a550e506ef">avrf_test_unit_ready</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests the state of the AVR Flash.  <a href="#ga6e798ae4398574d515c802a550e506ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaf09c88763a4deac0ac2c4aa9b49c12ba">avrf_read_capacity</a> (U32 *u32_nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gives the address of the last valid sector.  <a href="#gaf09c88763a4deac0ac2c4aa9b49c12ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaf950b7a4776b0e3215c35648fab8970d">avrf_wr_protect</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the write protected status of the memory.  <a href="#gaf950b7a4776b0e3215c35648fab8970d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaaef951f3f6464080d642206ce3373f9e">avrf_removal</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tells if the memory has been removed or not.  <a href="#gaaef951f3f6464080d642206ce3373f9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga33e2bcc937348de850e812a7237884fd">avrf_read_10</a> (U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a read operation of n sectors from a given address on.  <a href="#ga33e2bcc937348de850e812a7237884fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gae930b7ef893039dc7d223c465503f9eb">avrf_write_10</a> (U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction initialise the memory for a write operation.  <a href="#gae930b7ef893039dc7d223c465503f9eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gae3e4d52c834618e9dd4d53693e51e37c">avrf_read_open</a> (Uint32 pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens a DF memory in read mode at a given sector address.  <a href="#gae3e4d52c834618e9dd4d53693e51e37c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga47f968c9851adffa93ec0bb93fe199ec">avrf_read_close</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unselects the current DF memory.  <a href="#ga47f968c9851adffa93ec0bb93fe199ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga0f093c1d7161da224ecb07383d61f19e">avrf_read_sector</a> (Uint16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is optimized and writes nb-sector * 512 Bytes from DataFlash memory to USB controller.  <a href="#ga0f093c1d7161da224ecb07383d61f19e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaa02eeb6bbe862a09f6cdc9d1f1e7e626">avrf_write_open</a> (Uint32 pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens a DF memory in write mode at a given sector address.  <a href="#gaa02eeb6bbe862a09f6cdc9d1f1e7e626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga194c6ce2ff9866b05187d8390d0f941a">avrf_write_close</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the end of the logical sector (512B) and launch page programming.  <a href="#ga194c6ce2ff9866b05187d8390d0f941a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gafde2632a16c95692a907eada19dfaaef">avrf_write_sector</a> (Uint16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is optimized and writes nb-sector * 512 Bytes from USB controller to DataFlash memory.  <a href="#gafde2632a16c95692a907eada19dfaaef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gae299afa5d49375940e57f9642ef709a8">avrf_usb_read</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction transfer the memory data (programed in scsi_read_10) directly to the usb interface.  <a href="#gae299afa5d49375940e57f9642ef709a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga41a77d679390a374002e43a7e5b95f21">avrf_usb_write</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction transfer the usb data (programed in scsi_write_10) directly to the memory data.  <a href="#ga41a77d679390a374002e43a7e5b95f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga77a287c5aa53679242c3827b11a71252">get_nb_lun</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction return the number of logical unit.  <a href="#ga77a287c5aa53679242c3827b11a71252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga76c903dae1ac07d6ef569b5c44e1644b">get_cur_lun</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction return the current logical unit.  <a href="#ga76c903dae1ac07d6ef569b5c44e1644b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga51555be425eeacfd88e603b9cba97049">mem_test_unit_ready</a> (U8 lun)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction test the state of memory, and start the initialisation of the memory.  <a href="#ga51555be425eeacfd88e603b9cba97049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gace55e62f4e2b09da845c260ee52c69ab">mem_read_capacity</a> (U8 lun, U32 _MEM_TYPE_SLOW_ *u32_nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction return the capacity of the memory.  <a href="#gace55e62f4e2b09da845c260ee52c69ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaf4b64acad5f46d01e082d7a7301078df">mem_wr_protect</a> (U8 lun)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction return is the write protected mode.  <a href="#gaf4b64acad5f46d01e082d7a7301078df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gab56313733936ea087a9eb2285a913554">mem_removal</a> (U8 lun)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction inform about the memory type.  <a href="#gab56313733936ea087a9eb2285a913554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga1bc5f6636e0c33423bd45149c8b52aa5">memory_2_usb</a> (U8 lun, U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction returns a pointer to the LUN name.  <a href="#ga1bc5f6636e0c33423bd45149c8b52aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga009fb70f78b2582820da7d32ecbcb44f">usb_2_memory</a> (U8 lun, U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction trabsfer a data from usb to memory.  <a href="#ga009fb70f78b2582820da7d32ecbcb44f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga2d171e5d2acc8555ae136cb9acfb2fe7">memory_2_ram</a> (U8 lun, const U32 _MEM_TYPE_SLOW_ *addr, U8 _MEM_TYPE_SLOW_ *ram)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for RAM.  <a href="#ga2d171e5d2acc8555ae136cb9acfb2fe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga98acb7a8722060edfffefec80993111e">ram_2_memory</a> (U8 lun, const U32 _MEM_TYPE_SLOW_ *addr, U8 _MEM_TYPE_SLOW_ *ram)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction trabsfer a data from ram to memory.  <a href="#ga98acb7a8722060edfffefec80993111e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga99ef258150e099373ece59d16a473c01">stream_mem_to_mem</a> (U8 src_lun, U32 src_addr, U8 dest_lun, U32 dest_addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for streaming interface.  <a href="#ga99ef258150e099373ece59d16a473c01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga2118c372b3956b970b0dec90c6ed8592">stream_state</a> (U8 Id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state on a data transfer.  <a href="#ga2118c372b3956b970b0dec90c6ed8592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga12903ea72648ef9089fb8168a80dcf86">stream_stop</a> (U8 Id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the data transfer.  <a href="#ga12903ea72648ef9089fb8168a80dcf86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaffa6469099cc7713cfbfd73f6c5dd022">scsi_decode_command</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SCSI decoder function.  <a href="#gaffa6469099cc7713cfbfd73f6c5dd022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gae6a977561cdadab81fcb0a1ddf54e599">sbc_request_sense</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function manages the SCSI REQUEST SENSE command (0x03)  <a href="#gae6a977561cdadab81fcb0a1ddf54e599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga5ab123cdf7ce0be905307fad2e714557">sbc_inquiry</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function manages the SCSI INQUIRY command (0x12)  <a href="#ga5ab123cdf7ce0be905307fad2e714557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gace91bd174f189c655249a901e4ce138c">sbc_mode_sense</a> (Bool b_sense_10)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function manages the SCSI MODE SENSE command (0x1A for sense 6 and 0x5A for sense 10)  <a href="#gace91bd174f189c655249a901e4ce138c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga3afa976ae770c2ef5053d7b2c1b61dde">sbc_prevent_allow_medium_removal</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function manages the SCSI PREVENT ALLOW MEDIUM REMOVAL command (0x1E)  <a href="#ga3afa976ae770c2ef5053d7b2c1b61dde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a32a04cfe5f86c7200512a2dee798f8"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_good" ref="ga6a32a04cfe5f86c7200512a2dee798f8" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga6a32a04cfe5f86c7200512a2dee798f8">sbc_lun_status_is_good</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction send the UFI status GOOD. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03f2e185631cefb98ce3076deb698640"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_not_present" ref="ga03f2e185631cefb98ce3076deb698640" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga03f2e185631cefb98ce3076deb698640">sbc_lun_status_is_not_present</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction send the UFI status "lun not present". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga070e6444e67e90bc02263d8c7120f639"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_busy_or_change" ref="ga070e6444e67e90bc02263d8c7120f639" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga070e6444e67e90bc02263d8c7120f639">sbc_lun_status_is_busy_or_change</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction send the UFI status busy and change. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f9fe80f550dbf8d9c3c60516bb6dad6"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_fail" ref="ga8f9fe80f550dbf8d9c3c60516bb6dad6" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga8f9fe80f550dbf8d9c3c60516bb6dad6">sbc_lun_status_is_fail</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction send the UFI status FAIL. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4f9cd3f5771069c76997ba86944bffc"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_protected" ref="gaf4f9cd3f5771069c76997ba86944bffc" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaf4f9cd3f5771069c76997ba86944bffc">sbc_lun_status_is_protected</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This fonction send the UFI status FAIL because write protection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga8ad8d2f18d5af0ed75b541ab3ca9a7ff">usb_mass_storage_cbw</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Command Block Wrapper (CBW) management.  <a href="#ga8ad8d2f18d5af0ed75b541ab3ca9a7ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gaed223d0bc3ba362c7f3cc8766ff614f0">usb_mass_storage_csw</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Command Status Wrapper (CSW) management.  <a href="#gaed223d0bc3ba362c7f3cc8766ff614f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#gabb2f5aeb58ca9e0dac6004b5abbff30b">PROCESS_THREAD</a> (storage_process, ev, data_proc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Mass Storage Class Process.  <a href="#gabb2f5aeb58ca9e0dac6004b5abbff30b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17e7aa663c771d6bddfea612365b55ee"></a><!-- doxytag: member="usbstorage::usb_configuration_nb" ref="ga17e7aa663c771d6bddfea612365b55ee" args="" -->
U8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html#ga17e7aa663c771d6bddfea612365b55ee">usb_configuration_nb</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Public : (U8) usb_configuration_nb Store the number of the USB configuration used by the USB device when its value is different from zero, it means the device mode is enumerated Used with USB_DEVICE_FEATURE == ENABLED only /. <br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga3d068dfd6cc43279a8f57456a9898754"></a><!-- doxytag: member="ctrl_access.h::ID_STREAM_ERR" ref="ga3d068dfd6cc43279a8f57456a9898754" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ID_STREAM_ERR&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>---- Interface for streaming interface ---------------------------------- </p>

<p>Definition at line <a class="el" href="a00727_source.html#l00135">135</a> of file <a class="el" href="a00727_source.html">ctrl_access.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga77ad6433358d065ff854213e9373d7f5"></a><!-- doxytag: member="avr_flash.c::avrf_mem_init" ref="ga77ad6433358d065ff854213e9373d7f5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avrf_mem_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes the hw/sw ressources required to drive the AVR Flash. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<p>/ </p>

<p>Definition at line <a class="el" href="a00723_source.html#l00091">91</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga33e2bcc937348de850e812a7237884fd"></a><!-- doxytag: member="avr_flash.c::avrf_read_10" ref="ga33e2bcc937348de850e812a7237884fd" args="(U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_read_10 </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&#160;</td>
          <td class="paramname"><em>nb_sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function performs a read operation of n sectors from a given address on. </p>
<p>(sector = 512B)</p>
<p>DATA FLOW is: AVRF =&gt; USB</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Sector address to start the read from </td></tr>
    <tr><td class="paramname">nb_sector</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00178">178</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>References <a class="el" href="a00723_source.html#l00239">avrf_read_close()</a>, <a class="el" href="a00723_source.html#l00224">avrf_read_open()</a>, and <a class="el" href="a00723_source.html#l00269">avrf_read_sector()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf09c88763a4deac0ac2c4aa9b49c12ba"></a><!-- doxytag: member="avr_flash.c::avrf_read_capacity" ref="gaf09c88763a4deac0ac2c4aa9b49c12ba" args="(U32 *u32_nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_read_capacity </td>
          <td>(</td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>u32_nb_sector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function gives the address of the last valid sector. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*u32_nb_sector</td><td>number of sector (sector = 512B). OUT</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00122">122</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga47f968c9851adffa93ec0bb93fe199ec"></a><!-- doxytag: member="avr_flash.c::avrf_read_close" ref="ga47f968c9851adffa93ec0bb93fe199ec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avrf_read_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function unselects the current DF memory. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<p>/ </p>

<p>Definition at line <a class="el" href="a00723_source.html#l00239">239</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>Referenced by <a class="el" href="a00723_source.html#l00178">avrf_read_10()</a>.</p>

</div>
</div>
<a class="anchor" id="gae3e4d52c834618e9dd4d53693e51e37c"></a><!-- doxytag: member="avr_flash.c::avrf_read_open" ref="gae3e4d52c834618e9dd4d53693e51e37c" args="(Uint32 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_read_open </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function opens a DF memory in read mode at a given sector address. </p>
<p>NOTE: Address may not be synchronized on the beginning of a page (depending on the DF page size).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Logical sector address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The open succeeded -&gt; OK / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00224">224</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>Referenced by <a class="el" href="a00723_source.html#l00178">avrf_read_10()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f093c1d7161da224ecb07383d61f19e"></a><!-- doxytag: member="avr_flash.c::avrf_read_sector" ref="ga0f093c1d7161da224ecb07383d61f19e" args="(Uint16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_read_sector </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>nb_sector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is optimized and writes nb-sector * 512 Bytes from DataFlash memory to USB controller. </p>
<p>DATA FLOW is: DF =&gt; USB</p>
<p>NOTE:</p>
<ul>
<li>First call must be preceded by a call to the df_read_open() function,</li>
<li>The USB EPIN must have been previously selected,</li>
<li>USB ping-pong buffers are free,</li>
<li>As 512 is always a sub-multiple of page size, there is no need to check page end for each Bytes,</li>
<li>Interrupts are disabled during transfer to avoid timer interrupt,</li>
<li>nb_sector always &gt;= 1, cannot be zero.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_sector</td><td>number of contiguous sectors to read [IN]</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The read succeeded -&gt; OK / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00269">269</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>, <a class="el" href="a00736_source.html#l00548">Is_usb_write_enabled</a>, <a class="el" href="a00736_source.html#l00558">Usb_send_in</a>, and <a class="el" href="a00736_source.html#l00598">Usb_write_byte</a>.</p>

<p>Referenced by <a class="el" href="a00723_source.html#l00178">avrf_read_10()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaef951f3f6464080d642206ce3373f9e"></a><!-- doxytag: member="avr_flash.c::avrf_removal" ref="gaaef951f3f6464080d642206ce3373f9e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool avrf_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function tells if the memory has been removed or not. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE -&gt; The memory isn't removed / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00153">153</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e798ae4398574d515c802a550e506ef"></a><!-- doxytag: member="avr_flash.c::avrf_test_unit_ready" ref="ga6e798ae4398574d515c802a550e506ef" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_test_unit_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function tests the state of the AVR Flash. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD Else -&gt; CTRL_NO_PRESENT / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00106">106</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae299afa5d49375940e57f9642ef709a8"></a><!-- doxytag: member="avr_flash.c::avrf_usb_read" ref="gae299afa5d49375940e57f9642ef709a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_usb_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction transfer the memory data (programed in scsi_read_10) directly to the usb interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00499">499</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga41a77d679390a374002e43a7e5b95f21"></a><!-- doxytag: member="avr_flash.c::avrf_usb_write" ref="ga41a77d679390a374002e43a7e5b95f21" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_usb_write </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction transfer the usb data (programed in scsi_write_10) directly to the memory data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00510">510</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf950b7a4776b0e3215c35648fab8970d"></a><!-- doxytag: member="avr_flash.c::avrf_wr_protect" ref="gaf950b7a4776b0e3215c35648fab8970d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool avrf_wr_protect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the write protected status of the memory. </p>
<p>Only used by memory removal with a HARDWARE SPECIFIC write protected detection !!! The customer must unplug the memory to change this write protected status, which cannot be for a DF.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE -&gt; the memory is not write-protected (always) / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00140">140</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>.</p>

</div>
</div>
<a class="anchor" id="gae930b7ef893039dc7d223c465503f9eb"></a><!-- doxytag: member="avr_flash.c::avrf_write_10" ref="gae930b7ef893039dc7d223c465503f9eb" args="(U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_write_10 </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&#160;</td>
          <td class="paramname"><em>nb_sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction initialise the memory for a write operation. </p>
<p>DATA FLOW is: USB =&gt; DF</p>
<p>(sector = 512B) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Sector address to start write </td></tr>
    <tr><td class="paramname">nb_sector</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00200">200</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>References <a class="el" href="a00723_source.html#l00329">avrf_write_close()</a>, <a class="el" href="a00723_source.html#l00313">avrf_write_open()</a>, and <a class="el" href="a00723_source.html#l00400">avrf_write_sector()</a>.</p>

</div>
</div>
<a class="anchor" id="ga194c6ce2ff9866b05187d8390d0f941a"></a><!-- doxytag: member="avr_flash.c::avrf_write_close" ref="ga194c6ce2ff9866b05187d8390d0f941a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avrf_write_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function fills the end of the logical sector (512B) and launch page programming. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<p>/ </p>

<p>Definition at line <a class="el" href="a00723_source.html#l00329">329</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>Referenced by <a class="el" href="a00723_source.html#l00200">avrf_write_10()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa02eeb6bbe862a09f6cdc9d1f1e7e626"></a><!-- doxytag: member="avr_flash.c::avrf_write_open" ref="gaa02eeb6bbe862a09f6cdc9d1f1e7e626" args="(Uint32 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_write_open </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function opens a DF memory in write mode at a given sector address. </p>
<p>NOTE: If page buffer &gt; 512 bytes, page content is first loaded in buffer to be partially updated by write_byte or write64 functions.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Sector address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The open succeeded -&gt; OK / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00313">313</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>Referenced by <a class="el" href="a00723_source.html#l00200">avrf_write_10()</a>.</p>

</div>
</div>
<a class="anchor" id="gafde2632a16c95692a907eada19dfaaef"></a><!-- doxytag: member="avr_flash.c::avrf_write_sector" ref="gafde2632a16c95692a907eada19dfaaef" args="(Uint16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_write_sector </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>nb_sector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is optimized and writes nb-sector * 512 Bytes from USB controller to DataFlash memory. </p>
<p>Funtions to link USB DEVICE flow with data flash.</p>
<p>DATA FLOW is: USB =&gt; DF</p>
<p>NOTE:</p>
<ul>
<li>First call must be preceded by a call to the df_write_open() function,</li>
<li>As 512 is always a sub-multiple of page size, there is no need to check page end for each Bytes,</li>
<li>The USB EPOUT must have been previously selected,</li>
<li>Interrupts are disabled during transfer to avoid timer interrupt,</li>
<li>nb_sector always &gt;= 1, cannot be zero.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_sector</td><td>number of contiguous sectors to write [IN]</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The write succeeded -&gt; OK / </dd></dl>

<p>Definition at line <a class="el" href="a00723_source.html#l00400">400</a> of file <a class="el" href="a00723_source.html">avr_flash.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>, <a class="el" href="a00736_source.html#l00546">Is_usb_read_enabled</a>, <a class="el" href="a00736_source.html#l00538">Usb_ack_receive_out</a>, and <a class="el" href="a00736_source.html#l00596">Usb_read_byte</a>.</p>

<p>Referenced by <a class="el" href="a00723_source.html#l00200">avrf_write_10()</a>.</p>

</div>
</div>
<a class="anchor" id="ga76c903dae1ac07d6ef569b5c44e1644b"></a><!-- doxytag: member="ctrl_access.c::get_cur_lun" ref="ga76c903dae1ac07d6ef569b5c44e1644b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 get_cur_lun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return the current logical unit. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>U8 number of logical unit in the system </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00206">206</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

<p>Referenced by <a class="el" href="a00731_source.html#l00150">usb_mass_storage_cbw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77a287c5aa53679242c3827b11a71252"></a><!-- doxytag: member="ctrl_access.c::get_nb_lun" ref="ga77a287c5aa53679242c3827b11a71252" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 get_nb_lun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return the number of logical unit. </p>
<p>**** Listing of commun interface ****************************************</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>U8 number of logical unit in the system </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00192">192</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

<p>Referenced by <a class="el" href="a00737_source.html#l00089">usb_user_read_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gace55e62f4e2b09da845c260ee52c69ab"></a><!-- doxytag: member="ctrl_access.c::mem_read_capacity" ref="gace55e62f4e2b09da845c260ee52c69ab" args="(U8 lun, U32 _MEM_TYPE_SLOW_ *u32_nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> mem_read_capacity </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 _MEM_TYPE_SLOW_ *&#160;</td>
          <td class="paramname"><em>u32_nb_sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return the capacity of the memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number </td></tr>
    <tr><td class="paramname">u32_nb_sector</td><td>The sector to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>*u16_nb_sector number of sector (sector = 512B) </dd>
<dd>
Ctrl_status It is ready -&gt; CTRL_GOOD Memory unplug -&gt; CTRL_NO_PRESENT </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00288">288</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab56313733936ea087a9eb2285a913554"></a><!-- doxytag: member="ctrl_access.c::mem_removal" ref="gab56313733936ea087a9eb2285a913554" args="(U8 lun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool mem_removal </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction inform about the memory type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE -&gt; The memory is removal </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00410">410</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga51555be425eeacfd88e603b9cba97049"></a><!-- doxytag: member="ctrl_access.c::mem_test_unit_ready" ref="ga51555be425eeacfd88e603b9cba97049" args="(U8 lun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> mem_test_unit_ready </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction test the state of memory, and start the initialisation of the memory. </p>
<p>MORE (see SPC-3 §5.2.4) : The TEST UNIT READY command allows an application client to poll a logical unit until it is ready without the need to allocate space for returned data. The TEST UNIT READY command may be used to check the media status of logical units with removable media.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD Memory unplug -&gt; CTRL_NO_PRESENT Not initialize -&gt; CTRL_BUSY </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00225">225</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4b64acad5f46d01e082d7a7301078df"></a><!-- doxytag: member="ctrl_access.c::mem_wr_protect" ref="gaf4b64acad5f46d01e082d7a7301078df" args="(U8 lun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool mem_wr_protect </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return is the write protected mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<p>Only used by memory removal with a HARDWARE SPECIFIC write protected detection !!! The customer must be unplug the card for change this write protected mode.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE -&gt; the memory is protected </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00350">350</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d171e5d2acc8555ae136cb9acfb2fe7"></a><!-- doxytag: member="ctrl_access.c::memory_2_ram" ref="ga2d171e5d2acc8555ae136cb9acfb2fe7" args="(U8 lun, const U32 _MEM_TYPE_SLOW_ *addr, U8 _MEM_TYPE_SLOW_ *ram)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> memory_2_ram </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U32 _MEM_TYPE_SLOW_ *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8 _MEM_TYPE_SLOW_ *&#160;</td>
          <td class="paramname"><em>ram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for RAM. </p>
<p>This fonction tranfer one sector data from memory to ram</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number </td></tr>
    <tr><td class="paramname">addr</td><td>Sector address to start read (sector = 512B) </td></tr>
    <tr><td class="paramname">ram</td><td>Adresse of ram buffer (only xdata)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE -&gt; The memory is removal </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00726">726</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

<p>Referenced by <a class="el" href="a00726_source.html#l00931">stream_mem_to_mem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1bc5f6636e0c33423bd45149c8b52aa5"></a><!-- doxytag: member="ctrl_access.c::memory_2_usb" ref="ga1bc5f6636e0c33423bd45149c8b52aa5" args="(U8 lun, U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> memory_2_usb </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&#160;</td>
          <td class="paramname"><em>nb_sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction returns a pointer to the LUN name. </p>
<p>**** Listing of READ/WRITE interface ************************************</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to code string----------- Listing of READ/WRITE interface with MODE ACCESS REGISTER ------------- This fonction tranfer a data from memory to usb</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number </td></tr>
    <tr><td class="paramname">addr</td><td>Sector address to start read (sector = 512B) </td></tr>
    <tr><td class="paramname">nb_sector</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL Memory unplug -&gt; CTRL_NO_PRESENT </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00540">540</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabb2f5aeb58ca9e0dac6004b5abbff30b"></a><!-- doxytag: member="storage_task.c::PROCESS_THREAD" ref="gabb2f5aeb58ca9e0dac6004b5abbff30b" args="(storage_process, ev, data_proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCESS_THREAD </td>
          <td>(</td>
          <td class="paramtype">storage_process&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_proc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Mass Storage Class Process. </p>
<p>This is the link between USB and the "good stuff". In this routine data is received and processed by USB Storage Class </p>

<p>Definition at line <a class="el" href="a00731_source.html#l00108">108</a> of file <a class="el" href="a00731_source.html">storage_task.c</a>.</p>

<p>References <a class="el" href="a00442_source.html#l00103">CLOCK_SECOND</a>, <a class="el" href="a00450_source.html#l00206">etimer_expired()</a>, <a class="el" href="a00450_source.html#l00178">etimer_set()</a>, <a class="el" href="a00740_source.html#l00078">Is_device_enumerated</a>, <a class="el" href="a00736_source.html#l00554">Is_usb_receive_out</a>, <a class="el" href="a00461_source.html#l00121">PROCESS_BEGIN</a>, <a class="el" href="a00461_source.html#l00132">PROCESS_END</a>, <a class="el" href="a00461_source.html#l00158">PROCESS_WAIT_EVENT_UNTIL</a>, <a class="el" href="a00731_source.html#l00150">usb_mass_storage_cbw()</a>, <a class="el" href="a00731_source.html#l00235">usb_mass_storage_csw()</a>, and <a class="el" href="a00736_source.html#l00460">Usb_select_endpoint</a>.</p>

</div>
</div>
<a class="anchor" id="ga98acb7a8722060edfffefec80993111e"></a><!-- doxytag: member="ctrl_access.c::ram_2_memory" ref="ga98acb7a8722060edfffefec80993111e" args="(U8 lun, const U32 _MEM_TYPE_SLOW_ *addr, U8 _MEM_TYPE_SLOW_ *ram)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> ram_2_memory </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U32 _MEM_TYPE_SLOW_ *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8 _MEM_TYPE_SLOW_ *&#160;</td>
          <td class="paramname"><em>ram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction trabsfer a data from ram to memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number </td></tr>
    <tr><td class="paramname">addr</td><td>Sector address to start write (sector = 512B) </td></tr>
    <tr><td class="paramname">ram</td><td>Adresse of ram buffer (only xdata)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE -&gt; The memory is removal </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00826">826</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

<p>Referenced by <a class="el" href="a00726_source.html#l00931">stream_mem_to_mem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ab123cdf7ce0be905307fad2e714557"></a><!-- doxytag: member="scsi_decoder.c::sbc_inquiry" ref="ga5ab123cdf7ce0be905307fad2e714557" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_inquiry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI INQUIRY command (0x12) </p>
<p>The SCSI Inquiry field contains information regarding parameters of the target. For example:</p>
<ul>
<li>vendor identification</li>
<li>product identification</li>
<li>peripheral qualifier</li>
<li>peripheral device type</li>
<li>etc</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

<p>Definition at line <a class="el" href="a00729_source.html#l00291">291</a> of file <a class="el" href="a00729_source.html">scsi_decoder.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>, <a class="el" href="a00729_source.html#l00749">sbc_lun_status_is_good()</a>, <a class="el" href="a01041_source.html#l00170">TRUE</a>, and <a class="el" href="a00736_source.html#l00598">Usb_write_byte</a>.</p>

<p>Referenced by <a class="el" href="a00729_source.html#l00138">scsi_decode_command()</a>.</p>

</div>
</div>
<a class="anchor" id="gace91bd174f189c655249a901e4ce138c"></a><!-- doxytag: member="scsi_decoder.c::sbc_mode_sense" ref="gace91bd174f189c655249a901e4ce138c" args="(Bool b_sense_10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_mode_sense </td>
          <td>(</td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>b_sense_10</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI MODE SENSE command (0x1A for sense 6 and 0x5A for sense 10) </p>
<p>The SCSI mode sense function returns parameters to an application client. It is a complementary command to the SCSI MODE SELECT command.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b_sense_10</td><td>( TRUE = sense 10, TRUE = sense 6)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

<p>Definition at line <a class="el" href="a00729_source.html#l00558">558</a> of file <a class="el" href="a00729_source.html">scsi_decoder.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>, <a class="el" href="a00729_source.html#l00749">sbc_lun_status_is_good()</a>, and <a class="el" href="a01041_source.html#l00170">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00729_source.html#l00138">scsi_decode_command()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3afa976ae770c2ef5053d7b2c1b61dde"></a><!-- doxytag: member="scsi_decoder.c::sbc_prevent_allow_medium_removal" ref="ga3afa976ae770c2ef5053d7b2c1b61dde" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_prevent_allow_medium_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI PREVENT ALLOW MEDIUM REMOVAL command (0x1E) </p>
<p>The SCSI prevent allow medium removal command requests that the target enable or disable the removal of the medium in the logical unit.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

<p>Definition at line <a class="el" href="a00729_source.html#l00740">740</a> of file <a class="el" href="a00729_source.html">scsi_decoder.c</a>.</p>

<p>References <a class="el" href="a00729_source.html#l00749">sbc_lun_status_is_good()</a>, and <a class="el" href="a01041_source.html#l00170">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00729_source.html#l00138">scsi_decode_command()</a>.</p>

</div>
</div>
<a class="anchor" id="gae6a977561cdadab81fcb0a1ddf54e599"></a><!-- doxytag: member="scsi_decoder.c::sbc_request_sense" ref="gae6a977561cdadab81fcb0a1ddf54e599" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_request_sense </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI REQUEST SENSE command (0x03) </p>
<p>The SCSI Sense contains the status of the last command This status is composed of 3 Bytes :</p>
<ul>
<li>sense key (g_scsi_sense.key)</li>
<li>additional sense code (g_scsi_sense.asc)</li>
<li>additional sense code qualifier (g_scsi_sense.ascq)</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

<p>Definition at line <a class="el" href="a00729_source.html#l00231">231</a> of file <a class="el" href="a00729_source.html">scsi_decoder.c</a>.</p>

<p>References <a class="el" href="a00729_source.html#l00749">sbc_lun_status_is_good()</a>, <a class="el" href="a01041_source.html#l00170">TRUE</a>, and <a class="el" href="a00736_source.html#l00598">Usb_write_byte</a>.</p>

<p>Referenced by <a class="el" href="a00729_source.html#l00138">scsi_decode_command()</a>.</p>

</div>
</div>
<a class="anchor" id="gaffa6469099cc7713cfbfd73f6c5dd022"></a><!-- doxytag: member="scsi_decoder.c::scsi_decode_command" ref="gaffa6469099cc7713cfbfd73f6c5dd022" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool scsi_decode_command </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SCSI decoder function. </p>
<p>This function read the SCSI command and launches the appropriate function</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function FLASH length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

<p>Definition at line <a class="el" href="a00729_source.html#l00138">138</a> of file <a class="el" href="a00729_source.html">scsi_decoder.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>, <a class="el" href="a00729_source.html#l00291">sbc_inquiry()</a>, <a class="el" href="a00729_source.html#l00749">sbc_lun_status_is_good()</a>, <a class="el" href="a00729_source.html#l00558">sbc_mode_sense()</a>, <a class="el" href="a00729_source.html#l00740">sbc_prevent_allow_medium_removal()</a>, <a class="el" href="a00729_source.html#l00231">sbc_request_sense()</a>, and <a class="el" href="a01041_source.html#l00170">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00731_source.html#l00150">usb_mass_storage_cbw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga99ef258150e099373ece59d16a473c01"></a><!-- doxytag: member="ctrl_access.c::stream_mem_to_mem" ref="ga99ef258150e099373ece59d16a473c01" args="(U8 src_lun, U32 src_addr, U8 dest_lun, U32 dest_addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 stream_mem_to_mem </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>src_lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>dest_lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&#160;</td>
          <td class="paramname"><em>nb_sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for streaming interface. </p>
<p>This fonction copy a data from memory to other memory</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src_lun</td><td>The LUN of the source </td></tr>
    <tr><td class="paramname">src_addr</td><td>The address of the source </td></tr>
    <tr><td class="paramname">dest_lun</td><td>The LUN of the destination </td></tr>
    <tr><td class="paramname">dest_addr</td><td>The address of the destination </td></tr>
    <tr><td class="paramname">nb_sector</td><td>Number of sectors to transfer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00931">931</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

<p>References <a class="el" href="a00726_source.html#l00726">memory_2_ram()</a>, and <a class="el" href="a00726_source.html#l00826">ram_2_memory()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2118c372b3956b970b0dec90c6ed8592"></a><!-- doxytag: member="ctrl_access.c::stream_state" ref="ga2118c372b3956b970b0dec90c6ed8592" args="(U8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> stream_state </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>Id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the state on a data transfer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Id</td><td>transfer id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the state of the transfer CTRL_GOOD It is finish CTRL_BUSY It is running CTRL_FAIL It is fail </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00957">957</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga12903ea72648ef9089fb8168a80dcf86"></a><!-- doxytag: member="ctrl_access.c::stream_stop" ref="ga12903ea72648ef9089fb8168a80dcf86" args="(U8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 stream_stop </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>Id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop the data transfer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Id</td><td>Transfer id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of sector remainder </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00969">969</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga009fb70f78b2582820da7d32ecbcb44f"></a><!-- doxytag: member="ctrl_access.c::usb_2_memory" ref="ga009fb70f78b2582820da7d32ecbcb44f" args="(U8 lun, U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01706.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> usb_2_memory </td>
          <td>(</td>
          <td class="paramtype">U8&#160;</td>
          <td class="paramname"><em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&#160;</td>
          <td class="paramname"><em>nb_sector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction trabsfer a data from usb to memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lun</td><td>Logical unit number </td></tr>
    <tr><td class="paramname">addr</td><td>Sector address to start write (sector = 512B) </td></tr>
    <tr><td class="paramname">nb_sector</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL Memory unplug -&gt; CTRL_NO_PRESENT </dd></dl>

<p>Definition at line <a class="el" href="a00726_source.html#l00633">633</a> of file <a class="el" href="a00726_source.html">ctrl_access.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ad8d2f18d5af0ed75b541ab3ca9a7ff"></a><!-- doxytag: member="storage_task.c::usb_mass_storage_cbw" ref="ga8ad8d2f18d5af0ed75b541ab3ca9a7ff" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_mass_storage_cbw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Command Block Wrapper (CBW) management. </p>
<p>This function decodes the CBW command and stores the SCSI command</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length) </dd></dl>

<p><p>check if dCBWSignature is correct</p>
<p>'U'</p>
<p>'S'</p>
<p>'B'</p>
<p>'C'</p>
<p>Store CBW Tag to be repeated in CSW</p>
<p>if (bmCBWFlags.bit7 == 1) {direction = IN}</p>
<p>dummy CBWCBLength read </p>
</p>

<p>Definition at line <a class="el" href="a00731_source.html#l00150">150</a> of file <a class="el" href="a00731_source.html">storage_task.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00175">FALSE</a>, <a class="el" href="a00726_source.html#l00206">get_cur_lun()</a>, <a class="el" href="a00729_source.html#l00138">scsi_decode_command()</a>, <a class="el" href="a01041_source.html#l00170">TRUE</a>, <a class="el" href="a00736_source.html#l00538">Usb_ack_receive_out</a>, <a class="el" href="a00736_source.html#l00471">Usb_enable_stall_handshake</a>, <a class="el" href="a00736_source.html#l00596">Usb_read_byte</a>, and <a class="el" href="a00736_source.html#l00460">Usb_select_endpoint</a>.</p>

<p>Referenced by <a class="el" href="a00731_source.html#l00108">PROCESS_THREAD()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed223d0bc3ba362c7f3cc8766ff614f0"></a><!-- doxytag: member="storage_task.c::usb_mass_storage_csw" ref="gaed223d0bc3ba362c7f3cc8766ff614f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_mass_storage_csw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Command Status Wrapper (CSW) management. </p>
<p>This function sends the status in relation with the last CBW </p>

<p><p>write CSW Signature</p>
<p>'U'</p>
<p>'S'</p>
<p>'B'</p>
<p>'S' write stored CBW Tag</p>
<p>write data residue value</p>
<p>write command status</p>
<p>0 -&gt; PASS, 1 -&gt; FAIL </p>
</p>

<p>Definition at line <a class="el" href="a00731_source.html#l00235">235</a> of file <a class="el" href="a00731_source.html">storage_task.c</a>.</p>

<p>References <a class="el" href="a00736_source.html#l00483">Is_usb_endpoint_stall_requested</a>, <a class="el" href="a00736_source.html#l00552">Is_usb_receive_setup</a>, <a class="el" href="a00736_source.html#l00548">Is_usb_write_enabled</a>, <a class="el" href="a00739_source.html#l00118">usb_process_request()</a>, <a class="el" href="a00736_source.html#l00460">Usb_select_endpoint</a>, <a class="el" href="a00736_source.html#l00558">Usb_send_in</a>, and <a class="el" href="a00736_source.html#l00598">Usb_write_byte</a>.</p>

<p>Referenced by <a class="el" href="a00731_source.html#l00108">PROCESS_THREAD()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 20:13:18 for Contiki 2.5 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
