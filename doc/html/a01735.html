<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Contiki 2.5: The Rime communication stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The Rime communication stack</div>  </div>
<div class="ingroups"><a class="el" href="a01731.html">Communication stacks</a></div></div>
<div class="contents">

<p>The Rime communication stack provides a set of lightweight communication primitives ranging from best-effort anonymous local area broadcast to reliable network flooding.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01619.html">Rime buffer management</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The packetbuf module does Rime's buffer management. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01620.html">Packet queue</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The packetqueue module handles a list of queued packets. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01622.html">Rime queue buffer management</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The queuebuf module handles buffers that are queued. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html">Anonymous best-effort local area broadcast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The abc module sends packets to all local area neighbors. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01650.html">Announcements</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The Announcement primitive does local area announcements. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01651.html">Rimebroadcastannouncement</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The broadcast announcement module implements a periodic explicit announcement. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01652.html">Best-effort local area broadcast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The broadcast module sends packets to all local area neighbors with an a header that identifies the sender. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01653.html">Link estimate management</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The link estimate module is used for computing estimations of link quality. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01654.html">Collect neighbor management</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The neighbor module manages the neighbor table that is used by the Collect module. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01655.html">Tree-based hop-by-hop reliable data collection</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The collect module implements a hop-by-hop reliable data collection mechanism. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01656.html">Ipolite best effort local broadcast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The ipolite module sends one local area broadcast packet within one time interval. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01657.html">Mesh routing</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The mesh module sends packets using multi-hop routing to a specified receiver somewhere in the network. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01658.html">Best-effort multihop forwarding</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The multihop module implements a multihop forwarding mechanism. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01659.html">Neighbor discovery</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The neighbor-discovery module implements a periodic neighbor discovery mechanism. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01660.html">Best-effort network flooding</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The netflood module does best-effort flooding. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01661.html">Rimepoliteannouncement</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The polite announcement module implements a periodic explicit announcement. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01662.html">Polite anonymous best effort local broadcast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The polite module sends one local area broadcast packet within one time interval. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01663.html">Rime addresses</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The rimeaddr module is an abstract representation of addresses in Rime. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01665.html">Rime route discovery protocol</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The route-discovery module does route discovery for Rime. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01666.html">Rime route table</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The route module handles the route table in Rime. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01667.html">Single-hop reliable bulk data transfer</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The rudolph0 module implements a single-hop reliable bulk data transfer mechanism. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01668.html">Multi-hop reliable bulk data transfer</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The rudolph1 module implements a multi-hop reliable bulk data transfer mechanism. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01670.html">Single-hop reliable unicast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The reliable single-hop unicast primitive (runicast) reliably sends a packet to a single-hop neighbor. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01671.html">Stubborn best-effort local area broadcast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The stbroadcast module provides stubborn anonymous best-effort local area broadcast. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01672.html">Stubborn unicast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The stubborn single-hop unicast primitive (stunicast) repeatedly sends a packet to a single-hop neighbor using the unicast primitive. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01674.html">Reliable single-source multi-hop flooding</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The trickle module sends a single packet to all nodes on the network. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01675.html">Single-hop unicast</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The unicast module sends a packet to an identified single-hop neighbor. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00313.html">rime.h</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Header file for the Rime stack. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00331.html">collect-link-estimate.h</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Header file for the Collect link estimate. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00352.html">rime.c</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Rime initialization and common code. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#gaeb36eb1e9d4c51fae6ad6c96900b9602">rime_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Rime.  <a href="#gaeb36eb1e9d4c51fae6ad6c96900b9602"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#ga4d291022f2e378389e5f62bc81fb753e">rime_input</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an incoming packet to Rime.  <a href="#ga4d291022f2e378389e5f62bc81fb753e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#ga56565921c958b79ebffd5d81f66a8382">collect_link_estimate_new</a> (struct collect_link_estimate *le)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new link estimate.  <a href="#ga56565921c958b79ebffd5d81f66a8382"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#ga02550a907aba69885b98c4adc77e343e">collect_link_estimate_update_tx</a> (struct collect_link_estimate *le, uint8_t num_tx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a link estimate when a packet has been sent.  <a href="#ga02550a907aba69885b98c4adc77e343e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#ga8efd84e84f0da40d1655ded896c8052e">collect_link_estimate_update_tx_fail</a> (struct collect_link_estimate *le, uint8_t num_tx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a link estimate when a packet has failed to be sent.  <a href="#ga8efd84e84f0da40d1655ded896c8052e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#gad8e8f2e346306e3a73e67b4e41be7b45">collect_link_estimate_update_rx</a> (struct collect_link_estimate *le)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a link estimate when a packet has been received.  <a href="#gad8e8f2e346306e3a73e67b4e41be7b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01735.html#ga6776240121c0bd014923abb44e7e565b">collect_link_estimate</a> (struct collect_link_estimate *le)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the link estimate metric for a link estimate.  <a href="#ga6776240121c0bd014923abb44e7e565b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The Rime communication stack provides a set of lightweight communication primitives ranging from best-effort anonymous local area broadcast to reliable network flooding. </p>
<p>The protocols in the Rime stack are arranged in a layered fashion, where the more complex protocols are implemented using the less complex protocols.</p>
<p>We have chosen the communication primitives in the Rime stack based on what typical sensor network protocols use. Applications or protocols running on top of the Rime stack attach at any layer of the stack and use any of the communication primitives.</p>
<p>The Rime stack supports both single-hop and multi-hop communication primitives. The multi-hop primitives do not specify how packets are routed through the network. Instead, as the packet is sent across the network, the application or upper layer protocol is invoked at every node to choose the next-hop neighbor. This makes it possible to implement arbitrary routing protocols on top of the multi-hop primitives.</p>
<p>Protocols or applications running on top of the Rime stack can implement additional protocols that are not in the Rime stack. If a protocol or application running on top of the Rime stack would need a communication primitive that is not currently in the Rime stack, the application or protocol can implement it directly on top of other communication primitive in the stack.</p>
<p>For more information, see:</p>
<p>Adam Dunkels, Fredrik Österlind, and Zhitao He. An adaptive communication architecture for wireless sensor networks. In Proceedings of the Fifth ACM Conference on Networked Embedded Sensor Systems (SenSys 2007), Sydney, Australia, November 2007.</p>
<p><a href="http://www.sics.se/~adam/dunkels07adaptive.pdf">http://www.sics.se/~adam/dunkels07adaptive.pdf</a> <a href="http://www.sics.se/~adam/slides/dunkels07adaptive.ppt">http://www.sics.se/~adam/slides/dunkels07adaptive.ppt</a> </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6776240121c0bd014923abb44e7e565b"></a><!-- doxytag: member="collect&#45;link&#45;estimate.h::collect_link_estimate" ref="ga6776240121c0bd014923abb44e7e565b" args="(struct collect_link_estimate *le)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t collect_link_estimate </td>
          <td>(</td>
          <td class="paramtype">struct collect_link_estimate *&#160;</td>
          <td class="paramname"><em>le</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the link estimate metric for a link estimate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>A pointer to a link estimate structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current link estimate metric </dd></dl>

<p>Definition at line <a class="el" href="a00330_source.html#l00109">109</a> of file <a class="el" href="a00330_source.html">collect-link-estimate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga56565921c958b79ebffd5d81f66a8382"></a><!-- doxytag: member="collect&#45;link&#45;estimate.h::collect_link_estimate_new" ref="ga56565921c958b79ebffd5d81f66a8382" args="(struct collect_link_estimate *le)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collect_link_estimate_new </td>
          <td>(</td>
          <td class="paramtype">struct collect_link_estimate *&#160;</td>
          <td class="paramname"><em>le</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a new link estimate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>A pointer to a link estimate structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes a link estimate. </p>

<p>Definition at line <a class="el" href="a00330_source.html#l00064">64</a> of file <a class="el" href="a00330_source.html">collect-link-estimate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad8e8f2e346306e3a73e67b4e41be7b45"></a><!-- doxytag: member="collect&#45;link&#45;estimate.h::collect_link_estimate_update_rx" ref="gad8e8f2e346306e3a73e67b4e41be7b45" args="(struct collect_link_estimate *le)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collect_link_estimate_update_rx </td>
          <td>(</td>
          <td class="paramtype">struct collect_link_estimate *&#160;</td>
          <td class="paramname"><em>le</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a link estimate when a packet has been received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>A pointer to a link estimate structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function updates a link estimate. This function is called when a packet has been received. The function uses information from the packet buffer and its attributes. </p>

<p>Definition at line <a class="el" href="a00330_source.html#l00103">103</a> of file <a class="el" href="a00330_source.html">collect-link-estimate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga02550a907aba69885b98c4adc77e343e"></a><!-- doxytag: member="collect&#45;link&#45;estimate.h::collect_link_estimate_update_tx" ref="ga02550a907aba69885b98c4adc77e343e" args="(struct collect_link_estimate *le, uint8_t num_tx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collect_link_estimate_update_tx </td>
          <td>(</td>
          <td class="paramtype">struct collect_link_estimate *&#160;</td>
          <td class="paramname"><em>le</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a link estimate when a packet has been sent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>A pointer to a link estimate structure </td></tr>
    <tr><td class="paramname">num_tx</td><td>The number of times the packet was transmitted before it was ACKed</td></tr>
  </table>
  </dd>
</dl>
<p>This function updates a link estimate. This function is called when a packet has been sent. The function may use information from the packet buffer and the packet buffer attributes when computing the link estimate. </p>

<p>Definition at line <a class="el" href="a00330_source.html#l00071">71</a> of file <a class="el" href="a00330_source.html">collect-link-estimate.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00181">NULL</a>.</p>

<p>Referenced by <a class="el" href="a00330_source.html#l00096">collect_link_estimate_update_tx_fail()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8efd84e84f0da40d1655ded896c8052e"></a><!-- doxytag: member="collect&#45;link&#45;estimate.h::collect_link_estimate_update_tx_fail" ref="ga8efd84e84f0da40d1655ded896c8052e" args="(struct collect_link_estimate *le, uint8_t num_tx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collect_link_estimate_update_tx_fail </td>
          <td>(</td>
          <td class="paramtype">struct collect_link_estimate *&#160;</td>
          <td class="paramname"><em>le</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a link estimate when a packet has failed to be sent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">le</td><td>A pointer to a link estimate structure </td></tr>
    <tr><td class="paramname">num_tx</td><td>The number of times the packet was transmitted before it was given up on.</td></tr>
  </table>
  </dd>
</dl>
<p>This function updates a link estimate. This function is called when a packet has been sent. The function may use information from the packet buffer and the packet buffer attributes when computing the link estimate. </p>

<p>Definition at line <a class="el" href="a00330_source.html#l00096">96</a> of file <a class="el" href="a00330_source.html">collect-link-estimate.c</a>.</p>

<p>References <a class="el" href="a00330_source.html#l00071">collect_link_estimate_update_tx()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb36eb1e9d4c51fae6ad6c96900b9602"></a><!-- doxytag: member="rime.h::rime_init" ref="gaeb36eb1e9d4c51fae6ad6c96900b9602" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rime_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize Rime. </p>
<p>This function should be called from the system boot up code to initialize Rime. </p>

<p>Referenced by <a class="el" href="a01129_source.html#l00096">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d291022f2e378389e5f62bc81fb753e"></a><!-- doxytag: member="rime.h::rime_input" ref="ga4d291022f2e378389e5f62bc81fb753e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rime_input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send an incoming packet to Rime. </p>
<p>This function should be called by the network driver to hand over a packet to Rime for further processing. The packet should be placed in the packetbuf (with <a class="el" href="a01619.html#ga5fd9cb98f800733b6d9381bce81cd224" title="Copy from external data into the packetbuf.">packetbuf_copyfrom()</a>) before calling this function. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 20:13:19 for Contiki 2.5 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
