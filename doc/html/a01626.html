<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Contiki 2.5: The Contiki/uIP interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.5</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">The Contiki/uIP interface</div>  </div>
<div class="ingroups"><a class="el" href="a01741.html">The uIP TCP/IP stack</a></div></div>
<div class="contents">

<p>TCP/IP support in Contiki is implemented using the uIP TCP/IP stack.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00400.html">tcpip.h</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Header for the Contiki/uIP interface. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41aa744caa46913b3b3aedb2a4e78546"></a><!-- doxytag: member="tcpip::UIP_APPCALL" ref="ga41aa744caa46913b3b3aedb2a4e78546" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga41aa744caa46913b3b3aedb2a4e78546">UIP_APPCALL</a>&#160;&#160;&#160;tcpip_uipcall</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the application function that uIP should call in response to TCP/IP events. <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF process_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#gaadf3c3b5770cafe3da7f8cc4dd06625c">tcpip_event</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP event.  <a href="#gaadf3c3b5770cafe3da7f8cc4dd06625c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
TCP functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga8bc368a618bee21caad1c718ca5a1257">tcp_attach</a> (struct <a class="el" href="a00095.html">uip_conn</a> *conn, void *appstate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a TCP connection to the current process.  <a href="#ga8bc368a618bee21caad1c718ca5a1257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga54da317fbad65ee501d2a3bcceea9053">tcp_listen</a> (<a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a> port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a TCP port.  <a href="#ga54da317fbad65ee501d2a3bcceea9053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga8dca6c8d7480910a0ef8e44ddc1efae8">tcp_unlisten</a> (<a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a> port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a listening TCP port.  <a href="#ga8dca6c8d7480910a0ef8e44ddc1efae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF struct <a class="el" href="a00095.html">uip_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#gab273caac33a993c640488afeea0d62ae">tcp_connect</a> (<a class="el" href="a00109.html">uip_ipaddr_t</a> *ripaddr, <a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a> port, void *appstate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a TCP connection to the specified IP address and port.  <a href="#gab273caac33a993c640488afeea0d62ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga7ba71f5f4d459854a5b1e09e6d77b252">tcpip_poll_tcp</a> (struct <a class="el" href="a00095.html">uip_conn</a> *conn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a specified TCP connection to be polled.  <a href="#ga7ba71f5f4d459854a5b1e09e6d77b252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga228f0c0f1c20d43a7fda39b3b8f0fd4c"></a><!-- doxytag: member="tcpip::tcp_markconn" ref="ga228f0c0f1c20d43a7fda39b3b8f0fd4c" args="(conn, appstate)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_markconn</b>(conn, appstate)&#160;&#160;&#160;tcp_attach(conn, appstate)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
UDP functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga3cb4f212906fc7b8909a3f8938006470">udp_attach</a> (struct <a class="el" href="a00122.html">uip_udp_conn</a> *conn, void *appstate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the current process to a UDP connection.  <a href="#ga3cb4f212906fc7b8909a3f8938006470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF struct <a class="el" href="a00122.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga3a19e48d6d3d7e228edd61e42ea8e9f9">udp_new</a> (const <a class="el" href="a00109.html">uip_ipaddr_t</a> *ripaddr, <a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a> port, void *appstate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new UDP connection.  <a href="#ga3a19e48d6d3d7e228edd61e42ea8e9f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00122.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#gafff531c60e24d94b6dabaa8ae226a696">udp_broadcast_new</a> (<a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a> port, void *appstate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new UDP broadcast connection.  <a href="#gafff531c60e24d94b6dabaa8ae226a696"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga98f9cca40d8c2043f405ee372a6de0d1">tcpip_poll_udp</a> (struct <a class="el" href="a00122.html">uip_udp_conn</a> *conn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a specified UDP connection to be polled.  <a href="#ga98f9cca40d8c2043f405ee372a6de0d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga22b8211f05d7e2ef4d521274d07191e9"></a><!-- doxytag: member="tcpip::udp_markconn" ref="ga22b8211f05d7e2ef4d521274d07191e9" args="(conn, appstate)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udp_markconn</b>(conn, appstate)&#160;&#160;&#160;udp_attach(conn, appstate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga6afb919d5d0923a55252eeb46caf58d6">udp_bind</a>(conn, port)&#160;&#160;&#160;uip_udp_bind(conn, port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a UDP connection to a local port.  <a href="#ga6afb919d5d0923a55252eeb46caf58d6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
TCP/IP packet processing</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does address resolution and then calls tcpip_output.  <a href="#gaaf7bd597f63c175c2f5e90e10cc67c0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f3e06288277302a1fe329b3f68ca953"></a><!-- doxytag: member="tcpip::tcpip_is_forwarding" ref="ga9f3e06288277302a1fe329b3f68ca953" args="" -->
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_is_forwarding</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCIF void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#ga0d5e21d13844dbebd703fb8ed6b058d0">tcpip_input</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deliver an incoming packet to the TCP/IP stack.  <a href="#ga0d5e21d13844dbebd703fb8ed6b058d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab486de225a1420cad84e08068c12238f"></a><!-- doxytag: member="tcpip::tcpip_output" ref="gab486de225a1420cad84e08068c12238f" args="(void)" -->
<a class="el" href="a01725.html#ga4caecabca98b43919dd11be1c0d4cd8e">u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html#gab486de225a1420cad84e08068c12238f">tcpip_output</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output packet to layer 2 The eventual parameter is the MAC address of the destination. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b4b388c82ce2196de01a80a532a1d81"></a><!-- doxytag: member="tcpip::tcpip_set_outputfunc" ref="ga4b4b388c82ce2196de01a80a532a1d81" args="(u8_t(*f)(void))" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_set_outputfunc</b> (<a class="el" href="a01725.html#ga4caecabca98b43919dd11be1c0d4cd8e">u8_t</a>(*f)(void))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacccb4e63afa84573fbef8a071dbf8b5c"></a><!-- doxytag: member="tcpip::tcpip_set_forwarding" ref="gacccb4e63afa84573fbef8a071dbf8b5c" args="(forwarding)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_set_forwarding</b>(forwarding)&#160;&#160;&#160;<a class="el" href="a01626.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a> = (forwarding)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>TCP/IP support in Contiki is implemented using the uIP TCP/IP stack. </p>
<p>For sending and receiving data, Contiki uses the functions provided by the uIP module, but Contiki adds a set of functions for connection management. The connection management functions make sure that the uIP TCP/IP connections are connected to the correct process.</p>
<p>Contiki also includes an optional protosocket library that provides an API similar to the BSD socket API.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a01741.html">The uIP TCP/IP stack</a> </dd>
<dd>
<a class="el" href="a01621.html">Protosockets library</a> </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6afb919d5d0923a55252eeb46caf58d6"></a><!-- doxytag: member="tcpip.h::udp_bind" ref="ga6afb919d5d0923a55252eeb46caf58d6" args="(conn, port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udp_bind</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">conn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;uip_udp_bind(conn, port)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a UDP connection to a local port. </p>
<p>This function binds a UDP connection to a specified local port.</p>
<p>When a connection is created with <a class="el" href="a01626.html#ga3a19e48d6d3d7e228edd61e42ea8e9f9" title="Create a new UDP connection.">udp_new()</a>, it gets a local port number assigned automatically. If the application needs to bind the connection to a specified local port, this function should be used.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="a01633.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> usually is necessary.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection that is to be bound. </td></tr>
    <tr><td class="paramname">port</td><td>The port number in network byte order to which to bind the connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00400_source.html#l00262">262</a> of file <a class="el" href="a00400_source.html">tcpip.h</a>.</p>

<p>Referenced by <a class="el" href="a00393_source.html#l00136">simple_udp_register()</a>, and <a class="el" href="a00399_source.html#l00338">udp_broadcast_new()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8bc368a618bee21caad1c718ca5a1257"></a><!-- doxytag: member="tcpip.h::tcp_attach" ref="ga8bc368a618bee21caad1c718ca5a1257" args="(struct uip_conn *conn, void *appstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF void tcp_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00095.html">uip_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach a TCP connection to the current process. </p>
<p>This function attaches the current process to a TCP connection. Each TCP connection must be attached to a process in order for the process to be able to receive and send data. Additionally, this function can add a pointer with connection state to the connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the TCP connection.</td></tr>
    <tr><td class="paramname">appstate</td><td>An opaque pointer that will be passed to the process whenever an event occurs on the connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab273caac33a993c640488afeea0d62ae"></a><!-- doxytag: member="tcpip.h::tcp_connect" ref="gab273caac33a993c640488afeea0d62ae" args="(uip_ipaddr_t *ripaddr, u16_t port, void *appstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF struct <a class="el" href="a00095.html">uip_conn</a>* tcp_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00109.html">uip_ipaddr_t</a> *&#160;</td>
          <td class="paramname"><em>ripaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a TCP connection to the specified IP address and port. </p>
<p>This function opens a TCP connection to the specified port at the host specified with an IP address. Additionally, an opaque pointer can be attached to the connection. This pointer will be sent together with uIP events to the process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="a01633.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> usually is necessary.</dd>
<dd>
This function will only create the connection. The connection is not opened directly. uIP will try to open the connection the next time the uIP stack is scheduled by Contiki.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ripaddr</td><td>Pointer to the IP address of the remote host. </td></tr>
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54da317fbad65ee501d2a3bcceea9053"></a><!-- doxytag: member="tcpip.h::tcp_listen" ref="ga54da317fbad65ee501d2a3bcceea9053" args="(u16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF void tcp_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a>&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a TCP port. </p>
<p>This function opens a TCP port for listening. When a TCP connection request occurs for the port, the process will be sent a tcpip_event with the new connection request.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Port numbers must always be given in network byte order. The functions <a class="el" href="a01633.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> and <a class="el" href="a01741.html#gae4394b6b3cd81f73b0e64a93e0558e00" title="Convert 16-bit quantity from host byte order to network byte order.">uip_htons()</a> can be used to convert port numbers from host byte order to network byte order.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00006.html#a12">example-psock-server.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8dca6c8d7480910a0ef8e44ddc1efae8"></a><!-- doxytag: member="tcpip.h::tcp_unlisten" ref="ga8dca6c8d7480910a0ef8e44ddc1efae8" args="(u16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF void tcp_unlisten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a>&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a listening TCP port. </p>
<p>This function closes a listening TCP port.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Port numbers must always be given in network byte order. The functions <a class="el" href="a01633.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> and <a class="el" href="a01741.html#gae4394b6b3cd81f73b0e64a93e0558e00" title="Convert 16-bit quantity from host byte order to network byte order.">uip_htons()</a> can be used to convert port numbers from host byte order to network byte order.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number in network byte order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d5e21d13844dbebd703fb8ed6b058d0"></a><!-- doxytag: member="tcpip.h::tcpip_input" ref="ga0d5e21d13844dbebd703fb8ed6b058d0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF void tcpip_input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deliver an incoming packet to the TCP/IP stack. </p>
<p>This function is called by network device drivers to deliver an incoming packet to the TCP/IP stack. The incoming packet must be present in the uip_buf buffer, and the length of the packet must be in the global uip_len variable. </p>

<p>Definition at line <a class="el" href="a00399_source.html#l00540">540</a> of file <a class="el" href="a00399_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00181">NULL</a>, <a class="el" href="a00460_source.html#l00363">process_post_synch()</a>, <a class="el" href="a00430_source.html#l00143">uip_ext_len</a>, and <a class="el" href="a00428_source.html#l00144">uip_len</a>.</p>

<p>Referenced by <a class="el" href="a01254_source.html#l00330">mac_ethernetToLowpan()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ba71f5f4d459854a5b1e09e6d77b252"></a><!-- doxytag: member="tcpip.h::tcpip_poll_tcp" ref="ga7ba71f5f4d459854a5b1e09e6d77b252" args="(struct uip_conn *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_poll_tcp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00095.html">uip_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause a specified TCP connection to be polled. </p>
<p>This function causes uIP to poll the specified TCP connection. The function is used when the application has data that is to be sent immediately and do not wish to wait for the periodic uIP polling mechanism.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the TCP connection that should be polled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98f9cca40d8c2043f405ee372a6de0d1"></a><!-- doxytag: member="tcpip.h::tcpip_poll_udp" ref="ga98f9cca40d8c2043f405ee372a6de0d1" args="(struct uip_udp_conn *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF void tcpip_poll_udp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00122.html">uip_udp_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause a specified UDP connection to be polled. </p>
<p>This function causes uIP to poll the specified UDP connection. The function is used when the application has data that is to be sent immediately and do not wish to wait for the periodic uIP polling mechanism.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection that should be polled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00399_source.html#l00690">690</a> of file <a class="el" href="a00399_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="a00460_source.html#l00323">process_post()</a>.</p>

<p>Referenced by <a class="el" href="a00311_source.html#l00418">resolv_query()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3cb4f212906fc7b8909a3f8938006470"></a><!-- doxytag: member="tcpip.h::udp_attach" ref="ga3cb4f212906fc7b8909a3f8938006470" args="(struct uip_udp_conn *conn, void *appstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00122.html">uip_udp_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach the current process to a UDP connection. </p>
<p>This function attaches the current process to a UDP connection. Each UDP connection must have a process attached to it in order for the process to be able to receive and send data over the connection. Additionally, this function can add a pointer with connection state to the connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection.</td></tr>
    <tr><td class="paramname">appstate</td><td>An opaque pointer that will be passed to the process whenever an event occurs on the connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00399_source.html#l00309">309</a> of file <a class="el" href="a00399_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="a00429_source.html#l01356">uip_udp_conn::appstate</a>, and <a class="el" href="a00461_source.html#l00403">PROCESS_CURRENT</a>.</p>

</div>
</div>
<a class="anchor" id="gafff531c60e24d94b6dabaa8ae226a696"></a><!-- doxytag: member="tcpip.h::udp_broadcast_new" ref="gafff531c60e24d94b6dabaa8ae226a696" args="(u16_t port, void *appstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="a00122.html">uip_udp_conn</a>* udp_broadcast_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new UDP broadcast connection. </p>
<p>This function creates a new (link-local) broadcast UDP connection to a specified port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

<p>Definition at line <a class="el" href="a00399_source.html#l00338">338</a> of file <a class="el" href="a00399_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="a01041_source.html#l00181">NULL</a>, <a class="el" href="a00400_source.html#l00262">udp_bind</a>, <a class="el" href="a00399_source.html#l00320">udp_new()</a>, and <a class="el" href="a00429_source.html#l00919">uip_ipaddr</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a19e48d6d3d7e228edd61e42ea8e9f9"></a><!-- doxytag: member="tcpip.h::udp_new" ref="ga3a19e48d6d3d7e228edd61e42ea8e9f9" args="(const uip_ipaddr_t *ripaddr, u16_t port, void *appstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF struct <a class="el" href="a00122.html">uip_udp_conn</a>* udp_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html">uip_ipaddr_t</a> *&#160;</td>
          <td class="paramname"><em>ripaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01725.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new UDP connection. </p>
<p>This function creates a new UDP connection with the specified remote endpoint.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="a01633.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> usually is necessary.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a01626.html#ga6afb919d5d0923a55252eeb46caf58d6" title="Bind a UDP connection to a local port.">udp_bind()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ripaddr</td><td>Pointer to the IP address of the remote host. </td></tr>
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

<p>Definition at line <a class="el" href="a00399_source.html#l00320">320</a> of file <a class="el" href="a00399_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="a00429_source.html#l01356">uip_udp_conn::appstate</a>, <a class="el" href="a01041_source.html#l00181">NULL</a>, <a class="el" href="a00461_source.html#l00403">PROCESS_CURRENT</a>, and <a class="el" href="a00428_source.html#l00465">uip_udp_new()</a>.</p>

<p>Referenced by <a class="el" href="a00393_source.html#l00136">simple_udp_register()</a>, and <a class="el" href="a00399_source.html#l00338">udp_broadcast_new()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gaaf7bd597f63c175c2f5e90e10cc67c0c"></a><!-- doxytag: member="tcpip.h::tcpip_do_forwarding" ref="gaaf7bd597f63c175c2f5e90e10cc67c0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="a01626.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function does address resolution and then calls tcpip_output. </p>
<p>Is forwarding generally enabled? </p>

</div>
</div>
<a class="anchor" id="gaadf3c3b5770cafe3da7f8cc4dd06625c"></a><!-- doxytag: member="tcpip.h::tcpip_event" ref="gaadf3c3b5770cafe3da7f8cc4dd06625c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCIF process_event_t <a class="el" href="a01626.html#gaadf3c3b5770cafe3da7f8cc4dd06625c">tcpip_event</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The uIP event. </p>
<p>This event is posted to a process whenever a uIP event has occurred. </p>

<p>Definition at line <a class="el" href="a00399_source.html#l00084">84</a> of file <a class="el" href="a00399_source.html">tcpip.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 20:13:17 for Contiki 2.5 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
